<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on freire</title><link>https://blog.freire.dev.br/posts/</link><description>Recent content in Posts on freire</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 13 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.freire.dev.br/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>desenvolvimento Go e $GOPATH em 2020</title><link>https://blog.freire.dev.br/posts/desenvolvimento-go-2020/</link><pubDate>Sun, 13 Sep 2020 00:00:00 +0000</pubDate><guid>https://blog.freire.dev.br/posts/desenvolvimento-go-2020/</guid><description>Há alguns dias um colega meu me fez a seguinte pergunta: &amp;ldquo;Quero rodar Go em um lugar diferente do $HOME, é só mudar o $GOPATH?&amp;rdquo;. Este tipo de pergunta é bem recorrente quando se trata de Go, mas qual a razão?
A raiz do problema Em agosto de 2018 Go introduziu o suporte a módulos em sua versão 1.11. Desde então não há a necessidade de colocar seus projetos dentro do diretório $GOPATH/src.</description></item><item><title>diminuindo a lentidão do dnf</title><link>https://blog.freire.dev.br/posts/diminuindo-lentidao-dnf/</link><pubDate>Sun, 13 Sep 2020 00:00:00 +0000</pubDate><guid>https://blog.freire.dev.br/posts/diminuindo-lentidao-dnf/</guid><description>Uma das primeiras coisas que percebemos ao migrarmos de gerenciadores de pacotes como o apk ou o pacman para o dnf é sua lentidão.
Esta lentidão se deve principalmente pelo fato dele atualizar seu cache toda vez que realizamos alguma ação com ele, enquanto o apt, por exemplo, possui um comando dedicado a isso.
Podemos acelerar um pouco as coisas ao adicionar as seguintes flags ao arquivo /etc/dnf/dnf.conf:
max_parallel_downloads=10 fastestmirror=1</description></item><item><title>removendo itens duplicados em Javascript</title><link>https://blog.freire.dev.br/posts/removendo-duplicados-javascript/</link><pubDate>Sat, 12 Sep 2020 00:00:00 +0000</pubDate><guid>https://blog.freire.dev.br/posts/removendo-duplicados-javascript/</guid><description>Alguns exemplos de como remover itens duplicados em arrays.
Array Set() const arr = [&amp;#39;foo&amp;#39;, &amp;#39;bar&amp;#39;, &amp;#39;bar&amp;#39;]; const unique = [...new Set(arr)]; const arr = Array de objetos Array.filter() const arr = [{ name: &amp;#39;foo&amp;#39;, age: 20 }, { name: &amp;#39;foo&amp;#39;, age: 22 }, { name: &amp;#39;bar&amp;#39;, age: 25 }]; const unique = arr.filter((item, index, self) =&amp;gt; self.findIndex(value =&amp;gt; item.name === value.name) === index); for loop const arr = [{ name: &amp;#39;foo&amp;#39;, age: 20 }, { name: &amp;#39;foo&amp;#39;, age: 22 }, { name: &amp;#39;bar&amp;#39;, age: 25 }]; const unique = []; for (const item of arr) { if (!</description></item><item><title>setup declarativo de e-mail utilizando Nix e notmuch</title><link>https://blog.freire.dev.br/posts/setup-declarativo-email-nix/</link><pubDate>Thu, 06 Aug 2020 00:00:00 +0000</pubDate><guid>https://blog.freire.dev.br/posts/setup-declarativo-email-nix/</guid><description>Sempre utilizei o Thunderbird como cliente de e-mail, entretanto uma coisa sempre me incomodou: a busca é lenta. Isso se mostra verdadeiro até mesmo para uma pessoa que faz um uso leve de e-mails.
Aqui entra o notmuch, de acordo com seu próprio site, é um sistema de busca e tags globais para e-mails. Ele é encarregado por fazer buscas rápidas (o site garante que milhões de mensagens não são muito) e manter sua caixa de entrada vazia através de seu sistema de tags.</description></item><item><title>apagando mensagens do Discord com Python</title><link>https://blog.freire.dev.br/posts/deletando-mensagens-python/</link><pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate><guid>https://blog.freire.dev.br/posts/deletando-mensagens-python/</guid><description>Não sei vocês, mas eu costumo apagar minhas mensagens com frequência. Sempre sinto certa ansiedade por ter mensagens demais em locais demais e então decidi criar um bot que automatize parte dessa tarefa.
Requisitos Python 3.4 ou superior requests A Estratégia Minha primeira estratégia foi iterar as mensagens de cada canal que participo até chegar na primeira mensagem enviada, assim eu teria certeza que passei por todas minhas mensagens.</description></item></channel></rss>