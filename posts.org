#+HUGO_BASE_DIR: ./
* Notas @notas
** Diminuindo a lentidão do dnf :fedora:dnf:linux:
:PROPERTIES:
:export_file_name: lentidao-dnf
:export_date: 2020-09-13
:END:

Uma das primeiras coisas que percebemos ao migrarmos de gerenciadores de pacotes como o ~apk~ ou o ~pacman~ para o ~dnf~ é sua lentidão. Isso se deve principalmente pelo fato dele atualizar seu cache toda vez que realizamos alguma ação com ele, enquanto o ~apt~, por exemplo, possui um comando dedicado a isso.

Podemos acelerar um pouco as coisas ao adicionar as seguintes flags ao arquivo ~/etc/dnf/dnf.conf~:
- ~max_parallel_downloads=10~
- ~fastestmirror=1~

* Posts @posts
** Apagando mensagens do Discord com Python :python:discord:bot:
:PROPERTIES:
:EXPORT_FILE_NAME: deletando-mensagens-python
:EXPORT_DATE: 2020-08-01
:END:

Não sei vocês, mas eu costumo apagar minhas mensagens com frequência.   Sempre sinto certa ansiedade por ter mensagens demais em locais demais e então decidi criar um bot que automatize parte dessa tarefa.

*** Requisitos
- ~Python 3.4 ou superior~
  - ~requests~

*** A Estratégia
Minha primeira estratégia foi iterar as mensagens de cada canal que participo até chegar na primeira mensagem enviada, assim eu teria certeza que passei por todas minhas mensagens. Não preciso nem dizer que levaria dias para vasculhar servidores muito movimentados. Sendo assim, arrumei outra estratégia.

Parei um pouco para pensar e percebi que a forma mais fácil de pegar mensagens com parâmetros específicos é (pasmem!) utilizando a ferramenta de busca do próprio Discord! Bastou fazer uma busca com meu próprio usuário para descobrir nossa estratégia de busca. Anotemos como é nosso endpoint de busca:

~https://discord.com/api/v6/guilds/{guild_id}/messages/search?author_id={user_id}&max_id={max_id}~

- *guild_id*: o id da guild em que pretendemos realizar a busca;
- *user_id*: o id do seu usuário.
- *max_id*: esse id determina a partir de qual id pesquisaremos.

O retorno da API é mais ou menos assim:

#+BEGIN_SRC json
{
    "total_results": 1000,
    "messages": [
        [
            {
                "author": {
                    "id": "204643170250784768",
                },
                "hit": true,
                "id": "739263229619994695",
                "type": 0,
            }
        ]
    ]
}
#+END_SRC

- *total_results*: determina quantas mensagens o usuário possui em determinada guild;
- *messages*: é um lista de listas contendo as mensagens que batem com os parâmetros passados, entretanto também possui mensagens que servem para dar contexto aos resultados;
  - *author*: um objeto com informações gerais do autor da mensagem;
  - *channel_id*: o id do canal em que a mensagem fora enviada.
  - *hit*: aqui que fica o pulo do gato, mensagens que possuem o valor de hit como ~true~ terão foco na interface, ou seja, são as mensagens que queremos pegar;
  - *id*: o id da mensagem;
  - *type*: determina o [[https://discord.com/developers/docs/resources/channel#message-object-message-types][tipo da mensagem]].

*** Reunindo o necessário
 Agora que sabemos como realizar a busca, precisamos suprir as informações necessárias para tal. O primeiro passo é ler a [[https://discord.com/developers/docs/intro][documentação]] e tentar entender onde requisitar tais informações. Lá podemos ver que precisaremos de três endpoints além da busca.

 - ~GET /api/users/@me~: informações sobre o usuário;
 - ~GET /api/users/@me/guids~: informações sobre as guilds que o usuário faz parte;
 - ~DELETE /api/channels/{channel_id}/messages/{message_id}~: realiza a remoção de uma mensagem. Note que as informações necessárias já estão contidas no retorno da busca.

*** Mostre-me o código

Nosso primeiro passo será criar uma sessão do requests. Dessa forma poderemos persistir o cabeçalho contendo nosso token:

#+BEGIN_SRC python
import asyncio
import requests

URL_BASE = "https://discord.com"
URL_USERS_ME = f"{URL_BASE}/api/users/@me"
URL_USERS_ME_GUILDS = f"{URL_BASE}/api/users/@me/guilds"
URL_SEARCH_MESSAGES = "{}/guilds/{}/messages/search"
URL_DELETE_MESSAGE = "{}/channels/{}/messages/{}"


async def main():
    # seu token aqui
    TOKEN = ""

    session = requests.Session()
    session.headers.update({"Authorization": TOKEN})

asyncio.run(main())
#+END_SRC

#+RESULTS:

Utilizaremos essa sessão durante todo o programa. Todavia, antes de progredirmos, precisamos ter certeza que possuímos as permissões necessárias. Aqui verificaremos se somos autorizados à realizar requisições com nosso atual token.

#+BEGIN_SRC python
resp = session.get(URL_USERS_ME)
if resp.status_code == 403 or resp.status_code == 401:
    raise Exception("usuário não autorizado. token inválido")

user = resp.json()
guilds = session.get(URL_USERS_ME_GUILDS).json()
 #+END_SRC

A partir desse momento já possuímos todos os requisitos para realizar nossa primeira busca. Sendo assim, criaremos uma função para isso:

 #+BEGIN_SRC python
 async def search_messages(session, guild, user, params={}):
     user_id = user["id"]
     guild_id = guild["id"]
     params = { **params, "author_id": user_id }

     while True:
         resp = session.get(
             URL_SEARCH_MESSAGES.format(URL_BASE, guild_id)
             params=params
         )

         if resp.status_code == 429:
            retry_after = resp.json()["retry_after"]
            await asyncio sleep(retry_after / 1000)
            continue

        return resp.json()
 #+END_SRC

Essa função possui um método primitivo para lidar com o [[https://discord.com/developers/docs/topics/rate-limits][rate limit]] da api. Vemos na documentação que recebemos um JSON contendo o tempo que devemos esperar até a próxima requisição, então basta passá-lo para a função [[https://docs.python.org/3/library/asyncio-task.html#asyncio.sleep][sleep]].

Nossa próxima missão será criar uma função que remova uma mensagem. Agora ficou fácil:

#+BEGIN_SRC python
async def delete_message(session, message):
    channel_id = message["channel"]
    message_id = message["id"]

    while True:
        resp = session.delete(
            URL_DELETE_MESSAGE
            .format(URL_BASE, channel_id, message_id)
        )

        if resp.status_code == 429:
            retry_after = resp.json()["retry_after"]
            await asyncio.sleep(retry_after / 1000)
            continue

        if resp.status_code == 404 or resp.status == 204:
            return
#+END_SRC

Até o momento temos tudo o que é necessário para apagar todas nossas mensagens enviadas em guilds. Contudo, ainda podemos melhorar. Atualmente nosso programa busca uma guild e itera suas mensagens, mas de acordo com a documentação do Discord, podemos buscar em diversas guilds ao mesmo tempo, pois o /rate limit/ é individual para cada uma.

O Python introduziu a biblioteca [[https://docs.python.org/3.7/library/asyncio.html][asyncio]] a partir de sua versão 3.4. Podemos utilizar de seus poderes para agilizar nosso processo e para isso criaremos um /worker/ para buscar as mensagens e deletá-las.

#+BEGIN_SRC python
async def search_messages_worker(
    session,
    guild,
    user,
    params
):
    params = {}
    chat_id = chat["id"]

    while True:
        result = await search_messages(session, guild, user, params)
        total_results = result["total_results"]
        messages = result["messages"]

        # acabaram as mensagens
        if total_results == 0:
            return

        # pegando o id da mensagem mais velha
        ids = [msg["id"] for msg in messages]
        max_id = min(sorted(ids, key=int))

        # a proxima busca comecara a partir da mensagem mais antiga
        params = {**params, "max_id": max_id}

        messages_tasks = [
            asyncio.create_task(delete_message(session, {
                "id": msg["id"],
                "channel": msg["channel_id"]
            }))
            for msg in messages
        ]

        await asyncio.gather(*messages_tasks)
#+END_SRC

Fizemos bastante coisa nessa função, destrinchemos em pedaços.

Primeiramente em toda iteração do loop verificamos se possuímos mensagens na guild, caso não tenhamos finalizamos o worker.

#+BEGIN_SRC python
result = await search_messages(session, guild, user, params)
total_results = result["total_results"]
messages = result["messages"]

# acabaram as mensagens
if total_results == 0:
        return
#+END_SRC

Após isso nós determinamos qual a mensagem mais antiga para realizar a próxima busca.

#+BEGIN_SRC python
# pegando o id da mensagem mais velha
ids = [msg["id"] for msg in messages]
max_id = min(sorted(ids, key=int))

# a proxima busca comecara a partir da mensagem mais antiga
params = {**params, "max_id": max_id}
#+END_SRC

Bom, chegou a hora de utilizar o /asyncio/. Aqui nós criaremos diversas [[https://docs.python.org/3.7/library/asyncio-task.html#asyncio.create_task][tasks]] para apagar todas as mensagens recebidas na nossa busca. A função [[https://docs.python.org/3.7/library/asyncio-task.html#asyncio.gather][gather]] será responsável por receber as /tasks/ e rodá-las de forma concurrente.

#+BEGIN_SRC python
messages_tasks = [
    asyncio.create_task(delete_message(session, {
        "id": msg["id"],
        "channel": msg["channel_id"]
    }))
    for msg in messages
]

await asyncio.gather(*messages_tasks)
#+END_SRC

Agora vamos ao script final:

#+BEGIN_SRC python
import asyncio
import requests

URL_BASE = "https://discord.com"
URL_USERS_ME = f"{URL_BASE}/api/users/@me"
URL_USERS_ME_GUILDS = f"{URL_BASE}/api/users/@me/guilds"
URL_SEARCH_MESSAGES = "{}/guilds/{}/messages/search"
URL_DELETE_MESSAGE = "{}/channels/{}/messages/{}"


async def search_messages(session, guild, user, params={}):
    user_id = user["id"]
    guild_id = guild["id"]
    params = { **params, "author_id": user_id }

    while True:
        resp = session.get(
            URL_SEARCH_MESSAGES.format(URL_BASE, guild_id)
            params=params
        )

        if resp.status_code == 429:
            retry_after = resp.json()["retry_after"]
            await asyncio sleep(retry_after / 1000)
            continue

        return resp.json()


async def delete_message(
    session: requests.Session,
    message: dict,
):
    channel_id = message["channel"]
    message_id = message["id"]

    while True:
        resp = session.delete(
            URL_DELETE_MESSAGE
            .format(URL_BASE, channel_id, message_id)
        )

        if resp.status_code == 429:
            retry_after = resp.json()["retry_after"]
            await asyncio.sleep(retry_after / 1000)
            continue

        if resp.status_code == 404 or resp.status == 204:
            return


async def search_messages_worker(
    session,
    guild,
    user,
    params={}
):
    params = {}
    chat_id = chat["id"]

    while True:
        result = await search_messages(session, guild, user, params)
        total_results = result["total_results"]
        messages = result["messages"]

        # acabaram as mensagens
        if total_results == 0:
            return

        # pegando o id da mensagem mais velha
        ids = [msg["id"] for msg in messages]
        max_id = min(sorted(ids, key=int))

        # a proxima busca comecara a partir da mensagem mais antiga
        params = {**params, "max_id": max_id}

        messages_tasks = [
            asyncio.create_task(delete_message(session, {
                "id": msg["id"],
                "channel": msg["channel_id"]
            }))
            for msg in messages
        ]

        await asyncio.gather(*messages_tasks)


async def main():
    # seu token aqui
    TOKEN = ""

    session = requests.Session()
    session.headers.update({"Authorization": TOKEN})

    resp = session.get(URL_USERS_ME)
    if resp.status_code == 403 or resp.status_code == 401:
        raise Exception("usuário não autorizado. token inválido")

    user = resp.json()
    print(f"logged in as: {}", user["username"])
    guilds = session.get(URL_USERS_ME_GUILDS).json()


    tasks = [
        asyncio.create_task(
            search_messages_worker(session, guild, user)
        )
        for guild in guilds
    ]

    await asyncio.gather(*tasks)
    print("Done!")

asyncio.run(main())
#+END_SRC

Você pode conferir o código com algumas adições no [[https://github.com/ratsclub/nuke][Github]].

** Setup declarativo de e-mail utilizando Nix e notmuch :emacs:nix:email:
:PROPERTIES:
:EXPORT_FILE_NAME: setup-declarativo-email-nix
:EXPORT_DATE: 2020-08-06
:END:

Sempre utilizei o [[https://www.thunderbird.net/en-US/][Thunderbird]] como cliente de e-mail, entretanto uma coisa sempre me incomodou: a busca é lenta. Isso se mostra verdadeiro até mesmo para uma pessoa que faz um uso leve de e-mails.

Aqui entra o [[https://notmuchmail.org/][notmuch]], de acordo com seu próprio site, é um sistema de busca e tags globais para e-mails. Ele é encarregado por fazer buscas rápidas (o site garante que milhões de mensagens /não são muito/) e manter sua caixa de entrada vazia através de seu sistema de tags.

*** Requisitos
- [[https://nixos.org/learn.html][Nix]] (com [[https://github.com/rycee/home-manager][Home Manager]]) como gerenciador de pacotes
- [[https://isync.sourceforge.io/mbsync.html][mbsync]] para a sincronização dos e-mails via IMAP
- [[https://marlam.de/msmtp/][msmtp]] para enviar os e-mails

*** Nix e Home Manager

/Nix/ é a linguagem funcional utilizada pelo gerenciador de pacotes de mesmo nome. Através dela que declaramos pacotes, serviços e módulos que serão instalados em nosso sistema. Contudo, esse guia fora escrito em um sistema Ubuntu, logo não é preciso ser usuário de [[https://nixos.org/][NixOS]] (a distro oficial do Nix) para seguí-lo.

/Home Manager/ consiste em uma ferramenta feita na linguagem /Nix/ e tem como objetivo gerenciar seu ambiente de usuário de forma /declarativa/. Mas o que isso quer dizer? Você pode dar adeus a boa parte de suas /dotfiles/ e abraçar o modo Nix de configurar um ambiente. Um exemplo dado em seu repositório oficial é a configuração do ~gpg-agent~:

#+BEGIN_SRC nix
services.gpg-agent = {
  enable = true;
  defaultCacheTtl = 34560001;
  maxCacheTtl = 34560001;
  defaultCacheTtlSsh = 34560001;
  maxCacheTtlSsh = 34560001;
  enableSshSupport = true;
};
#+END_SRC

Por meio desta expressão o arquivo ~$GNUPGHOME/gpg-agent.conf~ será criado automaticamente:

#+BEGIN_SRC conf
enable-ssh-support
default-cache-ttl 34560001
default-cache-ttl-ssh 34560001
max-cache-ttl 34560001
max-cache-ttl-ssh 34560001
pinentry-program /nix/store/y355ly245pa6ps4813rrqc00rm4ki335-pinentry-1.1.0-gtk2/bin/pinentry
#+END_SRC

*** Configurando o e-mail

**** Programas e serviços

No decorrer da configuração será utilizado um arquivo único chamado ~email.nix~. Comecemos com a declaração dos programas e serviços necessários.

#+BEGIN_SRC nix
programs.mbsync.enable = true;
programs.msmtp.enable = true;
programs.notmuch = {
  enable = true;
  hooks = {
    preNew = "mbsync --all";
  };
};

services.mbsync = {
  enable = true;
  frequency = "*:0/5";
};
#+END_SRC

A sintaxe é bem direta, todavia devo ressaltar alguns pontos.

Primeiramente, a expressão ~programs.notmuch.hooks.preNew = "mbsync --all"~ faz o quê? Isto diz para o /notmuch/ buscar os e-mails diretamente do /mbsync/ ao rodarmos o comando ~notmuch new~. Logo após declaramos ~services.mbsync.frequency = "*:0/5"~ e isso nada mais é do que a frequência com que o ~mbsync~ será rodado. A notação ~*:0/5~ faz parte do [[https://www.freedesktop.org/software/systemd/man/systemd.time.html#Calendar%20Events][Calendar Events]] do systemd.

**** Contas

Chegou a hora de configurar nossas contas de e-mail. A expressão utilizada para isso é ~accounts.email.accounts."name".property~, dessa forma podemos configurar diversas contas de e-mail diferentes. Bom, mãos à obra!

#+BEGIN_SRC nix
accounts.email = {
  accounts.mustti =
    let
      emailAccount = "ratsclub@empresa.com.br";
      emailHost = "mail.empresa.com.br";
    in {
      realName = "Clube dos Ratos";
      address = emailAccount;
      userName = emailAccount;
      primary = true;

      imap.host = emailHost;
      smtp.host = emailHost;
      msmtp.enable = true;
      notmuch.enable = true;

      mbsync = {
        enable = true;
        create = "both";
        expunge = "both";
      };

      signature = {
        text = ''
            Clube dos Ratos
            https://empresa.com.br/
          '';
        showSignature = "append";
      };

      passwordCommand = "${pkgs.pass}/bin/pass empresa/email";
    };
};
#+END_SRC

 As partes sobre ~imap~ e ~smtp~ são bem óbvias. Assim como habilitar os programas ~msmtp~ e ~notmuch~. Já o ~mbsync~ possui algumas propriedades interessantes:

 - *create*: a permissão de criar novos e-mails;
 - *expunge*: a permissão de deletar e-mails.

Definindo o valor de ambos como ~both~ fará com que modificações sejam replicadas em ambos ambientes, local e servidor.

Nos resta a propriedade ~passwordCommand~, ela é responsável por prover a senha de seu e-mail. Eu utilzo o [[https://www.passwordstore.org/][pass]] para isso, mas você também pode utilizar o ~gnupg~, ~keepassxc~, entre outros. Basta passar um comando shell à esta propriedade.

*** Conclusão

Configurar uma conta de e-mail utilizando o /Nix/ foi bem mais fácil do que eu esperava. Isso claro, graças ao /Home Manager/. Sem ele provavelmente teríamos muito mais trabalho.

Agora basta escolher seu [[https://notmuchmail.org/frontends/][cliente]] e aproveitar o /notmuch/. Para usuários de emacs há o cliente oficial [[https://notmuchmail.org/notmuch-emacs/][notmuch-emacs]] e caso seja usuário de [[https://github.com/hlissner/doom-emacs][Doom Emacs]], basta adicioná-lo em seu ~init.el~. Como sou um usuário novato de Emacs, não sabia que precisaria configurar meu domínio de saída, basta adicioná-lo para evitar o erro ~i-did-not-set--mail-host-address--so-tickle-me~.

#+BEGIN_SRC elisp
(use-package! notmuch
  :config
  (setq mail-host-address "empresa.com.br"))
#+END_SRC

O arquivo de configuração final ficou assim:

#+BEGIN_SRC nix
{ pkgs, ... }:

{
  programs.mbsync.enable = true;
  programs.msmtp.enable = true;
  programs.notmuch = {
    enable = true;
    hooks = {
      preNew = "mbsync --all";
    };
  };

  services.mbsync = {
    enable = true;
    frequency = "*:0/5";
  };

  accounts.email = {
    accounts.mustti =
      let
        emailAccount = "ratsclub@empresa.com.br";
        emailHost = "mail.empresa.com.br";
      in {
        realName = "Clube dos Ratos";
        address = emailAccount;
        userName = emailAccount;
        primary = true;

        imap.host = emailHost;
        smtp.host = emailHost;
        msmtp.enable = true;
        notmuch.enable = true;

        mbsync = {
          enable = true;
          create = "both";
          expunge = "both";
        };

        signature = {
          text = ''
            Clube dos Ratos
            https://empresa.com.br/
          '';
          showSignature = "append";
        };

        passwordCommand = "${pkgs.pass}/bin/pass empresa/email";
      };
  };
}
#+END_SRC

** Como configuro o $GOPATH? :go:
:PROPERTIES:
:EXPORT_FILE_NAME: desenvolvendo-go-2020
:EXPORT_DATE: 2020-09-13
:END:

Resposta curta: você não precisa.

Há alguns dias um [[https://github.com/d4sein][colega]] meu me fez a seguinte pergunta: "Quero rodar Go em um lugar diferente do $HOME, é só mudar o $GOPATH?". Este tipo de pergunta é bem recorrente quando se trata de Go, mas qual a razão?

*** A raiz do problema
Em agosto de 2018 [[https://golang.org][Go]] introduziu o suporte a módulos em sua versão [[https://golang.org/doc/go1.11#modules][1.11]]. Desde então não há a necessidade de colocar seus projetos dentro do diretório ~$GOPATH/src~. Entretanto, em 2018 já havia quase uma década de conteúdos publicados na internet sobre Go... e esses incluem artigos que não fazem uso de módulos.

É enorme a chance de um novato procurar algum conteúdo e acabar caindo em um guia que faz uso do destemido ~$GOPATH~.

*** Configuração pós-módulos
Primeiramente você pode esquecer sobre a variável ~$GOROOT~, essa variável só é necessária caso você queira implementar algo diretamente na linguagem ou sua /standard library/.

Agora a variável ~$GOPATH~ serve para dizer ao Go onde ele deve salvar boa parte de seus arquivos. Entre os arquivos está o diretório ~$GOPATH/bin~, ele é responsável por armazenar os programas baixados através dos comandos ~go get~ e ~go install~. Adicione este diretório ao seu ~$PATH~ para ter acesso imediato aos programas baixados.

*** Desenvolvendo com módulos
Antes de mais nada, *não utilize* o diretório ~$GOPATH/src~ para seus projetos! Agora você está em seu próprio diretório, basta rodar o comando ~go mod init nome-do-seu-repositório-git~ [fn:: Um nome como github.com/username/reponame] para iniciá-lo.
