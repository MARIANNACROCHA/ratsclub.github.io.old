#+HUGO_BASE_DIR: ./
* Notas :@notas:
** diminuindo a lentidão do dnf :fedora:dnf:linux:
:PROPERTIES:
:export_file_name: diminuindo-lentidao-dnf
:export_date: 2020-09-13
:END:

Uma das primeiras coisas que percebemos ao migrarmos de gerenciadores de pacotes como o ~apk~ ou o ~pacman~ para o ~dnf~ é sua lentidão.

Esta lentidão se deve principalmente pelo fato dele atualizar seu cache toda vez que realizamos alguma ação com ele, enquanto o ~apt~, por exemplo, possui um comando dedicado a isso.

Podemos acelerar um pouco as coisas ao adicionar as seguintes flags ao arquivo ~/etc/dnf/dnf.conf~:

#+begin_src config
max_parallel_downloads=10
fastestmirror=1
#+end_src

** removendo itens duplicados em Javascript :javascript:
:PROPERTIES:
:export_file_name: removendo-duplicados-javascript
:export_date: 2020-09-12
:END:

Alguns exemplos de como remover itens duplicados em arrays.

*** Array
**** Set()
#+begin_src javascript
const arr = ['foo', 'bar', 'bar'];
const unique = [...new Set(arr)];
#+end_src
#+begin_src javascript
const arr =
#+end_src
*** Array de objetos
**** Array.filter()
**** for loop
#+begin_src javascript
const arr = [{ name: 'foo', age: 20 }, { name: 'foo', age: 22 }, { name: 'bar', age: 25 }];

const unique = [];
for (const item of arr) {
    if (!unique.find(item => item.name)) {
        unique.push(item);
    }
}
#+end_src

**** Map()
#+begin_src javascript
const arr = [{ name: 'foo', age: 20 }, { name: 'foo', age: 22 }, { name: 'bar', age: 25 }];
const uniqueMap = new Map(arr.map(item => [`${item.name}\t${item.age}`, item]));
const uniqueArr = [...uniqueMap.values()];
#+end_src

* Posts :@posts:
** apagando mensagens do Discord com Python :python:discord:bot:
:PROPERTIES:
:EXPORT_FILE_NAME: deletando-mensagens-python
:EXPORT_DATE: 2020-08-01
:END:

Não sei vocês, mas eu costumo apagar minhas mensagens com frequência.   Sempre sinto certa ansiedade por ter mensagens demais em locais demais e então decidi criar um bot que automatize parte dessa tarefa.

*** Requisitos
- ~Python 3.4 ou superior~
  - ~requests~

*** A Estratégia
Minha primeira estratégia foi iterar as mensagens de cada canal que participo até chegar na primeira mensagem enviada, assim eu teria certeza que passei por todas minhas mensagens. Não preciso nem dizer que levaria dias para vasculhar servidores muito movimentados. Sendo assim, arrumei outra estratégia.

Parei um pouco para pensar e percebi que a forma mais fácil de pegar mensagens com parâmetros específicos é (pasmem!) utilizando a ferramenta de busca do próprio Discord! Bastou fazer uma busca com meu próprio usuário para descobrir nossa estratégia de busca. Anotemos como é nosso endpoint de busca:

~https://discord.com/api/v6/guilds/{guild_id}/messages/search?author_id={user_id}&max_id={max_id}~

- *guild_id*: o id da guild em que pretendemos realizar a busca;
- *user_id*: o id do seu usuário.
- *max_id*: esse id determina a partir de qual id pesquisaremos.

O retorno da API é mais ou menos assim:

#+BEGIN_SRC json
{
    "total_results": 1000,
    "messages": [
        [
            {
                "author": {
                    "id": "204643170250784768",
                },
                "hit": true,
                "id": "739263229619994695",
                "type": 0,
            }
        ]
    ]
}
#+END_SRC

- *total_results*: determina quantas mensagens o usuário possui em determinada guild;
- *messages*: é um lista de listas contendo as mensagens que batem com os parâmetros passados, entretanto também possui mensagens que servem para dar contexto aos resultados;
  - *author*: um objeto com informações gerais do autor da mensagem;
  - *channel_id*: o id do canal em que a mensagem fora enviada.
  - *hit*: aqui que fica o pulo do gato, mensagens que possuem o valor de hit como ~true~ terão foco na interface, ou seja, são as mensagens que queremos pegar;
  - *id*: o id da mensagem;
  - *type*: determina o [[https://discord.com/developers/docs/resources/channel#message-object-message-types][tipo da mensagem]].

*** Reunindo o necessário
 Agora que sabemos como realizar a busca, precisamos suprir as informações necessárias para tal. O primeiro passo é ler a [[https://discord.com/developers/docs/intro][documentação]] e tentar entender onde requisitar tais informações. Lá podemos ver que precisaremos de três endpoints além da busca.

 - ~GET /api/users/@me~: informações sobre o usuário;
 - ~GET /api/users/@me/guids~: informações sobre as guilds que o usuário faz parte;
 - ~DELETE /api/channels/{channel_id}/messages/{message_id}~: realiza a remoção de uma mensagem. Note que as informações necessárias já estão contidas no retorno da busca.

*** Mostre-me o código

Nosso primeiro passo será criar uma sessão do requests. Dessa forma poderemos persistir o cabeçalho contendo nosso token:

#+BEGIN_SRC python
import asyncio
import requests

URL_BASE = "https://discord.com"
URL_USERS_ME = f"{URL_BASE}/api/users/@me"
URL_USERS_ME_GUILDS = f"{URL_BASE}/api/users/@me/guilds"
URL_SEARCH_MESSAGES = "{}/guilds/{}/messages/search"
URL_DELETE_MESSAGE = "{}/channels/{}/messages/{}"


async def main():
    # seu token aqui
    TOKEN = ""

    session = requests.Session()
    session.headers.update({"Authorization": TOKEN})

asyncio.run(main())
#+END_SRC

#+RESULTS:

Utilizaremos essa sessão durante todo o programa. Todavia, antes de progredirmos, precisamos ter certeza que possuímos as permissões necessárias. Aqui verificaremos se somos autorizados à realizar requisições com nosso atual token.

#+BEGIN_SRC python
resp = session.get(URL_USERS_ME)
if resp.status_code == 403 or resp.status_code == 401:
    raise Exception("usuário não autorizado. token inválido")

user = resp.json()
guilds = session.get(URL_USERS_ME_GUILDS).json()
 #+END_SRC

A partir desse momento já possuímos todos os requisitos para realizar nossa primeira busca. Sendo assim, criaremos uma função para isso:

 #+BEGIN_SRC python
 async def search_messages(session, guild, user, params={}):
     user_id = user["id"]
     guild_id = guild["id"]
     params = { **params, "author_id": user_id }

     while True:
         resp = session.get(
             URL_SEARCH_MESSAGES.format(URL_BASE, guild_id)
             params=params
         )

         if resp.status_code == 429:
            retry_after = resp.json()["retry_after"]
            await asyncio sleep(retry_after / 1000)
            continue

        return resp.json()
 #+END_SRC

Essa função possui um método primitivo para lidar com o [[https://discord.com/developers/docs/topics/rate-limits][rate limit]] da api. Vemos na documentação que recebemos um JSON contendo o tempo que devemos esperar até a próxima requisição, então basta passá-lo para a função [[https://docs.python.org/3/library/asyncio-task.html#asyncio.sleep][sleep]].

Nossa próxima missão será criar uma função que remova uma mensagem. Agora ficou fácil:

#+BEGIN_SRC python
async def delete_message(session, message):
    channel_id = message["channel"]
    message_id = message["id"]

    while True:
        resp = session.delete(
            URL_DELETE_MESSAGE
            .format(URL_BASE, channel_id, message_id)
        )

        if resp.status_code == 429:
            retry_after = resp.json()["retry_after"]
            await asyncio.sleep(retry_after / 1000)
            continue

        if resp.status_code == 404 or resp.status == 204:
            return
#+END_SRC

Até o momento temos tudo o que é necessário para apagar todas nossas mensagens enviadas em guilds. Contudo, ainda podemos melhorar. Atualmente nosso programa busca uma guild e itera suas mensagens, mas de acordo com a documentação do Discord, podemos buscar em diversas guilds ao mesmo tempo, pois o /rate limit/ é individual para cada uma.

O Python introduziu a biblioteca [[https://docs.python.org/3.7/library/asyncio.html][asyncio]] a partir de sua versão 3.4. Podemos utilizar de seus poderes para agilizar nosso processo e para isso criaremos um /worker/ para buscar as mensagens e deletá-las.

#+BEGIN_SRC python
async def search_messages_worker(
    session,
    guild,
    user,
    params
):
    params = {}
    chat_id = chat["id"]

    while True:
        result = await search_messages(session, guild, user, params)
        total_results = result["total_results"]
        messages = result["messages"]

        # acabaram as mensagens
        if total_results == 0:
            return

        # pegando o id da mensagem mais velha
        ids = [msg["id"] for msg in messages]
        max_id = min(sorted(ids, key=int))

        # a proxima busca comecara a partir da mensagem mais antiga
        params = {**params, "max_id": max_id}

        messages_tasks = [
            asyncio.create_task(delete_message(session, {
                "id": msg["id"],
                "channel": msg["channel_id"]
            }))
            for msg in messages
        ]

        await asyncio.gather(*messages_tasks)
#+END_SRC

Fizemos bastante coisa nessa função, destrinchemos em pedaços.

Primeiramente em toda iteração do loop verificamos se possuímos mensagens na guild, caso não tenhamos finalizamos o worker.

#+BEGIN_SRC python
result = await search_messages(session, guild, user, params)
total_results = result["total_results"]
messages = result["messages"]

# acabaram as mensagens
if total_results == 0:
        return
#+END_SRC

Após isso nós determinamos qual a mensagem mais antiga para realizar a próxima busca.

#+BEGIN_SRC python
# pegando o id da mensagem mais velha
ids = [msg["id"] for msg in messages]
max_id = min(sorted(ids, key=int))

# a proxima busca comecara a partir da mensagem mais antiga
params = {**params, "max_id": max_id}
#+END_SRC

Bom, chegou a hora de utilizar o /asyncio/. Aqui nós criaremos diversas [[https://docs.python.org/3.7/library/asyncio-task.html#asyncio.create_task][tasks]] para apagar todas as mensagens recebidas na nossa busca. A função [[https://docs.python.org/3.7/library/asyncio-task.html#asyncio.gather][gather]] será responsável por receber as /tasks/ e rodá-las de forma concurrente.

#+BEGIN_SRC python
messages_tasks = [
    asyncio.create_task(delete_message(session, {
        "id": msg["id"],
        "channel": msg["channel_id"]
    }))
    for msg in messages
]

await asyncio.gather(*messages_tasks)
#+END_SRC

Agora vamos ao script final:

#+BEGIN_SRC python
import asyncio
import requests

URL_BASE = "https://discord.com"
URL_USERS_ME = f"{URL_BASE}/api/users/@me"
URL_USERS_ME_GUILDS = f"{URL_BASE}/api/users/@me/guilds"
URL_SEARCH_MESSAGES = "{}/guilds/{}/messages/search"
URL_DELETE_MESSAGE = "{}/channels/{}/messages/{}"


async def search_messages(session, guild, user, params={}):
    user_id = user["id"]
    guild_id = guild["id"]
    params = { **params, "author_id": user_id }

    while True:
        resp = session.get(
            URL_SEARCH_MESSAGES.format(URL_BASE, guild_id)
            params=params
        )

        if resp.status_code == 429:
            retry_after = resp.json()["retry_after"]
            await asyncio sleep(retry_after / 1000)
            continue

        return resp.json()


async def delete_message(
    session: requests.Session,
    message: dict,
):
    channel_id = message["channel"]
    message_id = message["id"]

    while True:
        resp = session.delete(
            URL_DELETE_MESSAGE
            .format(URL_BASE, channel_id, message_id)
        )

        if resp.status_code == 429:
            retry_after = resp.json()["retry_after"]
            await asyncio.sleep(retry_after / 1000)
            continue

        if resp.status_code == 404 or resp.status == 204:
            return


async def search_messages_worker(
    session,
    guild,
    user,
    params={}
):
    params = {}
    chat_id = chat["id"]

    while True:
        result = await search_messages(session, guild, user, params)
        total_results = result["total_results"]
        messages = result["messages"]

        # acabaram as mensagens
        if total_results == 0:
            return

        # pegando o id da mensagem mais velha
        ids = [msg["id"] for msg in messages]
        max_id = min(sorted(ids, key=int))

        # a proxima busca comecara a partir da mensagem mais antiga
        params = {**params, "max_id": max_id}

        messages_tasks = [
            asyncio.create_task(delete_message(session, {
                "id": msg["id"],
                "channel": msg["channel_id"]
            }))
            for msg in messages
        ]

        await asyncio.gather(*messages_tasks)


async def main():
    # seu token aqui
    TOKEN = ""

    session = requests.Session()
    session.headers.update({"Authorization": TOKEN})

    resp = session.get(URL_USERS_ME)
    if resp.status_code == 403 or resp.status_code == 401:
        raise Exception("usuário não autorizado. token inválido")

    user = resp.json()
    print(f"logged in as: {}", user["username"])
    guilds = session.get(URL_USERS_ME_GUILDS).json()


    tasks = [
        asyncio.create_task(
            search_messages_worker(session, guild, user)
        )
        for guild in guilds
    ]

    await asyncio.gather(*tasks)
    print("Done!")

asyncio.run(main())
#+END_SRC

Você pode conferir o código com algumas adições no [[https://github.com/ratsclub/nuke][Github]].

** setup declarativo de e-mail utilizando Nix e notmuch :emacs:nix:email:
:PROPERTIES:
:EXPORT_FILE_NAME: setup-declarativo-email-nix
:EXPORT_DATE: 2020-08-06
:END:

Sempre utilizei o [[https://www.thunderbird.net/en-US/][Thunderbird]] como cliente de e-mail, entretanto uma coisa sempre me incomodou: a busca é lenta. Isso se mostra verdadeiro até mesmo para uma pessoa que faz um uso leve de e-mails.

Aqui entra o [[https://notmuchmail.org/][notmuch]], de acordo com seu próprio site, é um sistema de busca e tags globais para e-mails. Ele é encarregado por fazer buscas rápidas (o site garante que milhões de mensagens /não são muito/) e manter sua caixa de entrada vazia através de seu sistema de tags.

*** Requisitos
- [[https://nixos.org/learn.html][Nix]] (com [[https://github.com/rycee/home-manager][Home Manager]]) como gerenciador de pacotes
- [[https://isync.sourceforge.io/mbsync.html][mbsync]] para a sincronização dos e-mails via IMAP
- [[https://marlam.de/msmtp/][msmtp]] para enviar os e-mails

*** Nix e Home Manager

/Nix/ é a linguagem funcional utilizada pelo gerenciador de pacotes de mesmo nome. Através dela que declaramos pacotes, serviços e módulos que serão instalados em nosso sistema. Contudo, esse guia fora escrito em um sistema Ubuntu, logo não é preciso ser usuário de [[https://nixos.org/][NixOS]] (a distro oficial do Nix) para seguí-lo.

/Home Manager/ consiste em uma ferramenta feita na linguagem /Nix/ e tem como objetivo gerenciar seu ambiente de usuário de forma /declarativa/. Mas o que isso quer dizer? Você pode dar adeus a boa parte de suas /dotfiles/ e abraçar o modo Nix de configurar um ambiente. Um exemplo dado em seu repositório oficial é a configuração do ~gpg-agent~:

#+BEGIN_SRC nix
services.gpg-agent = {
  enable = true;
  defaultCacheTtl = 34560001;
  maxCacheTtl = 34560001;
  defaultCacheTtlSsh = 34560001;
  maxCacheTtlSsh = 34560001;
  enableSshSupport = true;
};
#+END_SRC

Por meio desta expressão o arquivo ~$GNUPGHOME/gpg-agent.conf~ será criado automaticamente:

#+BEGIN_SRC conf
enable-ssh-support
default-cache-ttl 34560001
default-cache-ttl-ssh 34560001
max-cache-ttl 34560001
max-cache-ttl-ssh 34560001
pinentry-program /nix/store/y355ly245pa6ps4813rrqc00rm4ki335-pinentry-1.1.0-gtk2/bin/pinentry
#+END_SRC

*** Configurando o e-mail

**** Programas e serviços

No decorrer da configuração será utilizado um arquivo único chamado ~email.nix~. Comecemos com a declaração dos programas e serviços necessários.

#+BEGIN_SRC nix
programs.mbsync.enable = true;
programs.msmtp.enable = true;
programs.notmuch = {
  enable = true;
  hooks = {
    preNew = "mbsync --all";
  };
};

services.mbsync = {
  enable = true;
  frequency = "*:0/5";
};
#+END_SRC

A sintaxe é bem direta, todavia devo ressaltar alguns pontos.

Primeiramente, a expressão ~programs.notmuch.hooks.preNew = "mbsync --all"~ faz o quê? Isto diz para o /notmuch/ buscar os e-mails diretamente do /mbsync/ ao rodarmos o comando ~notmuch new~. Logo após declaramos ~services.mbsync.frequency = "*:0/5"~ e isso nada mais é do que a frequência com que o ~mbsync~ será rodado. A notação ~*:0/5~ faz parte do [[https://www.freedesktop.org/software/systemd/man/systemd.time.html#Calendar%20Events][Calendar Events]] do systemd.

**** Contas

Chegou a hora de configurar nossas contas de e-mail. A expressão utilizada para isso é ~accounts.email.accounts."name".property~, dessa forma podemos configurar diversas contas de e-mail diferentes. Bom, mãos à obra!

#+BEGIN_SRC nix
accounts.email = {
  accounts.mustti =
    let
      emailAccount = "ratsclub@empresa.com.br";
      emailHost = "mail.empresa.com.br";
    in {
      realName = "Clube dos Ratos";
      address = emailAccount;
      userName = emailAccount;
      primary = true;

      imap.host = emailHost;
      smtp.host = emailHost;
      msmtp.enable = true;
      notmuch.enable = true;

      mbsync = {
        enable = true;
        create = "both";
        expunge = "both";
      };

      signature = {
        text = ''
            Clube dos Ratos
            https://empresa.com.br/
          '';
        showSignature = "append";
      };

      passwordCommand = "${pkgs.pass}/bin/pass empresa/email";
    };
};
#+END_SRC

 As partes sobre ~imap~ e ~smtp~ são bem óbvias. Assim como habilitar os programas ~msmtp~ e ~notmuch~. Já o ~mbsync~ possui algumas propriedades interessantes:

 - *create*: a permissão de criar novos e-mails;
 - *expunge*: a permissão de deletar e-mails.

Definindo o valor de ambos como ~both~ fará com que modificações sejam replicadas em ambos ambientes, local e servidor.

Nos resta a propriedade ~passwordCommand~, ela é responsável por prover a senha de seu e-mail. Eu utilzo o [[https://www.passwordstore.org/][pass]] para isso, mas você também pode utilizar o ~gnupg~, ~keepassxc~, entre outros. Basta passar um comando shell à esta propriedade.

*** Conclusão

Configurar uma conta de e-mail utilizando o /Nix/ foi bem mais fácil do que eu esperava. Isso claro, graças ao /Home Manager/. Sem ele provavelmente teríamos muito mais trabalho.

Agora basta escolher seu [[https://notmuchmail.org/frontends/][cliente]] e aproveitar o /notmuch/. Para usuários de emacs há o cliente oficial [[https://notmuchmail.org/notmuch-emacs/][notmuch-emacs]] e caso seja usuário de [[https://github.com/hlissner/doom-emacs][Doom Emacs]], basta adicioná-lo em seu ~init.el~. Como sou um usuário novato de Emacs, não sabia que precisaria configurar meu domínio de saída, basta adicioná-lo para evitar o erro ~i-did-not-set--mail-host-address--so-tickle-me~.

#+BEGIN_SRC elisp
(use-package! notmuch
  :config
  (setq mail-host-address "empresa.com.br"))
#+END_SRC

O arquivo de configuração final ficou assim:

#+BEGIN_SRC nix
{ pkgs, ... }:

{
  programs.mbsync.enable = true;
  programs.msmtp.enable = true;
  programs.notmuch = {
    enable = true;
    hooks = {
      preNew = "mbsync --all";
    };
  };

  services.mbsync = {
    enable = true;
    frequency = "*:0/5";
  };

  accounts.email = {
    accounts.mustti =
      let
        emailAccount = "ratsclub@empresa.com.br";
        emailHost = "mail.empresa.com.br";
      in {
        realName = "Clube dos Ratos";
        address = emailAccount;
        userName = emailAccount;
        primary = true;

        imap.host = emailHost;
        smtp.host = emailHost;
        msmtp.enable = true;
        notmuch.enable = true;

        mbsync = {
          enable = true;
          create = "both";
          expunge = "both";
        };

        signature = {
          text = ''
            Clube dos Ratos
            https://empresa.com.br/
          '';
          showSignature = "append";
        };

        passwordCommand = "${pkgs.pass}/bin/pass empresa/email";
      };
  };
}
#+END_SRC

** desenvolvimento Go e $GOPATH em 2020 :go:
:PROPERTIES:
:EXPORT_FILE_NAME: desenvolvimento-go-2020
:EXPORT_DATE: 2020-09-13
:END:

Há alguns dias um [[https://github.com/d4sein][colega]] meu me fez a seguinte pergunta: "Quero rodar Go em um lugar diferente do $HOME, é só mudar o $GOPATH?". Este tipo de pergunta é bem recorrente quando se trata de Go, mas qual a razão?

*** A raiz do problema
Em agosto de 2018 [[https://golang.org][Go]] introduziu o suporte a módulos em sua versão [[https://golang.org/doc/go1.11#modules][1.11]]. Desde então não há a necessidade de colocar seus projetos dentro do diretório ~$GOPATH/src~. Entretanto, em 2018 já havia quase uma década de conteúdos publicados na internet sobre Go... e esses incluem muitos artigos que não fazem o uso de módulos.

É enorme a chance de um novato procurar algum conteúdo e acabar caindo em um guia que faz uso do destemido ~$GOPATH~.

*** Configuração pós-módulos
Primeiramente você pode esquecer sobre a variável ~$GOROOT~, essa variável só é necessária caso você queira implementar algo diretamente na linguagem ou sua /standard library/.

Agora a variável ~$GOPATH~ serve para dizer ao Go onde ele deve salvar boa parte de seus arquivos. Entre os arquivos está o diretório ~$GOPATH/bin~, ele é responsável por armazenar os programas baixados através dos comandos ~go get~ e ~go install~. Adicione este diretório ao seu ~$PATH~ para ter acesso imediato aos programas baixados.

*** Desenvolvendo com módulos
Antes de mais nada, *não utilize* o diretório ~$GOPATH/src~ para seus projetos! Agora que você está em seu próprio diretório, basta rodar o comando ~go mod init nome-do-seu-repositório-git~ [fn:: Um nome como github.com/username/reponame] para iniciá-lo.

** conhecendo o IPFS :ipfs:p2p:
:EXPORT_FILE_NAME: conhecendo-ipfs
:EXPORT_DATE: 2019-10-22

*** IPFS? É de comer?

[[https://ipfs.io][IPFS]] é a sigla para /Inter-Planetary File System/. Trata-se de um sistema distribuído ([[https://pt.wikipedia.org/wiki/Peer-to-peer][Peer-to-Peer]]) para armazenamento e acesso de arquivos, websites, aplicações e dados.

Mas o que isso quer dizer, exatamente? Imagine que você está fazendo uma pesquisa na internet sobre Vincent Van Gogh. Você provavelmente começará pela página de Vincent Van Gogh na [[https://pt.wikipedia.org/][Wikipedia]] que será algo como:

~https://en.wikipedia.org/wiki/Vincent_Van_Gogh~

Quando você colocar essa URL no seu navegador, você está pedindo para que um computador da Wikipedia lhe forneça a página sobre Vincent Van Gogh. Entretanto, essa não é a única opção para você saber mais sobre Vincent Van Gogh. Se você usa o IPFS, seu computador requisitará a página assim:

~/ipfs/QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco/wiki/Vincent_Van_Gogh.html~

O IPFS sabe onde buscar essa informação pelo seu conteúdo, não sua localização. A versão IPFS do artigo sobre Vincent Van Gogh é representada por aquele texto de letras e números no meio da URL (/QmXoy/...), e invés de pedir a um computador da Wikipedia por aquela página, seu computador utilizará o IPFS para pedir a página a todos os computadores do mundo que possuem essa página. Ele lhe trará as informações sobre Vincent Van Gogh de todas as pessoas que as tenha, não só dos computadores da Wikipedia.

*** Por que isso importa?

Tornar possível baixar um arquivo de muitos locais que não são gerenciados por uma única organização.

- /Uma internet resiliente/: Se alguém derrubar os servidores da Wikipedia ou um engenheiro comete um grande erro que cause a queda dos servidores, você ainda conseguirá visualizar a página a partir de outra pessoa.

- /Dificulta a censura de conteúdo/: Como os arquivos no IPFS podem vir de diversos lugares, é bem difícil para que qualquer um (mesmo que sejam estados, corporações ou qualquer outra pessoa) bloquear coisas. Em 2017, a Turquia bloqueou a Wikipedia e a Espanha bloqueou websites relacionados ao movimento de independência da Catalunha.

- /Pode acelerar a web quando você está distante ou desconectado/: Se você consegue um arquivo de alguém próximo ao invés de alguém a milhares de quilômetros de distância, claramente tornará o processo mais rápido. Isso é especialmente valioso se sua comunidade tem uma rede local (os computadores são interligados), mas não possue uma boa conexão à internet. (Organizações com grande poder aquisitivo e conhecimento técnico fazem isso hoje em dia utilizando múltiplos bancos de dados e servidores que fornecem conteúdos estáticos (fotos, vídeos, textos...). IPFS quer tornar isso possível para todos.)

*** Mas de onde saiu esse nome?

De acordo com o projeto, há o esforço de construir um sistema que funcione através de lugares tão desconectados ou tão distantes quanto planetas. Por isso o nome /Inter-Planetary File System/.

*** Chega de enrolação! Quero saber como funciona!

Você viu um pouco sobre os conceitos e ideias do IPFS. Agora abordaremos alguns dos princípios básicos do sistema.

*** Links não mudam no IPFS

Sobre o link da página do Vincent Van Gogh que vimos acima. Parece meio estranho, não?

~/ipfs/QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco/wiki/Vincent_Van_Gogh.html~

Esse amontoado de letras após //ipfs// é chamado de /identificador de conteúdo/ e é como o IPFS consegue conteúdos de diversos lugares.

URLS e caminhos de arquivos tradicionais como...

- https://en.wikipedia.org/wiki/Vincent_Van_Gogh
- /Users/Joao/Documents/file.doc
- C:\Users\Joao\My Documents\apresentacao.ppt

...identificam um arquivo onde está localizado - em qual computador e em qual pasta de seu disco rígido ele está. Isso não funciona se o arquivo está em diversos lugares como o computador do seu vizinho ou daquele seu amigo de outro estado.

Entretanto, o IPFS não se baseia na localização do arquivo e, sim no conteúdo do arquivo. O identificador de conteúdo nada mais é do que um identificador único do conteúdo do arquivo. Todavia, como o endereço de um arquivo é criado a partir de seu conteúdo, links no IPFS não podem ser alterados.

Claro que pessoas querem atualizar arquivo e mudar seus conteúdos o tempo todo. Contudo, não querem ter que enviar um novo link toda vez que o arquivo fora alterado. Isso é totalmente possível no universo IPFS, mas esse artigo não entrará em detalhes sobre isso.

É importante lembrar que usar o IPFS é completamente participativo e colaborativo. Se ninguém que utiliza o IPFS tem um arquivo com certo identificador para os outros acessarem, você não poderá obtê-lo. No entanto, nada pode ser removido do IPFS enquanto alguém tenha interesse o bastante de mantê-lo disponível.

*** É tudo sobre posse e participação

Enquanto há muita coisa complexa por debaixo do capô do IPFS, as ideias fundamentais são sobre mudar como as redes de pessoas e computadores se comunicam. Hoje a internet é estruturada em cima de propriedade e acesso, isso é, você obtém arquivos de quem os possui - isso se eles te garantirem o acesso. IPFS é baseado na idea de posse e participação, ou seja, muitas pessoas possuem os arquivos uns dos outros e participam em mantê-los disponíveis.

Isso significa que IPFS só funciona bem quando pessoas estão participando de forma ativa. Se você usa o seu computador para compartilhar arquivos usando o IPFS, ao desligá-lo, outras pessoas não serão capazes de obter esses arquivos de você. Porém o IPFS já dispõe desse tipo de compartilhamento, você pode combinar com amigos ou fazer parcerias com instituições (por exemplo: museus e bibliotecas podem vir a trabalhar em conjuto) para compartilhar os arquivos uns dos outros.
